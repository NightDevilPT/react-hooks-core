---
alwaysApply: true
---

# React Hookify - Development Rules & Patterns

## ğŸ¯ Core Principles

1. **SSR-First**: All hooks MUST be compatible with Next.js and server-side rendering
2. **Type-Safe**: Full TypeScript support with proper generics and inference
3. **Performance**: Optimize for minimal re-renders and bundle size
4. **Error Resilient**: Graceful fallbacks and comprehensive error handling
5. **Production-Ready**: Write code that can run in production without modifications
6. **Production-Grade Quality**: All hooks and components MUST be professional, optimized, and robust to prevent breaking production applications. This includes:
   - Comprehensive error boundaries and try-catch blocks
   - Null/undefined checks for all external APIs and browser features
   - Proper cleanup of all subscriptions, event listeners, and timers
   - No side effects that could cause memory leaks
   - Defensive programming practices (validate inputs, handle edge cases)
   - Stable APIs that don't introduce breaking changes
   - Extensive testing coverage before release
   - Code review and quality checks for all implementations
7. **Zero Dependencies**: This package MUST be a pure package with no external dependencies (except React and React-DOM as peer dependencies). This means:
   - NO third-party packages in dependencies
   - NO utility libraries (lodash, ramda, etc.)
   - NO helper libraries
   - Use only native JavaScript/TypeScript APIs
   - Use only browser native APIs (when needed)
   - All utility functions must be implemented internally
   - Keep the bundle size minimal and avoid dependency bloat
   - Ensure compatibility and avoid version conflicts for end users

---

## ğŸ“ Complete Project Structure

```
react-hookify/
â”‚
â”œâ”€â”€ src/                                    # Source code
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/                              # Common/Core hooks (used anywhere in the app)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ [feature-name]/                 # Feature folder (e.g., storage, browser, timer, ui)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/                      # Feature-specific hooks
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useHookName.ts          # Individual hook file
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useAnotherHook.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts                # Export all hooks in this feature
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ interface/                  # Feature-specific TypeScript types
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useHookName.interface.ts # Types for specific hook
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useAnotherHook.interface.ts # Types for another hook
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FeatureProvider.interface.ts # Types for provider/context (if exists)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts                # Export all types
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ __tests__/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useHookName.test.tsx
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ useAnotherHook.test.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ context/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FeatureProvider.test.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ integration.test.tsx    # Feature integration tests
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ docs/                       # Feature-specific documentation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md               # Feature overview
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useHookName.md          # Hook documentation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useAnotherHook.md       # Another hook documentation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FeatureProvider.md      # Provider documentation (if exists)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ index.ts                    # Feature main export (hooks + context + types)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ index.ts                        # Export all common/core hooks
â”‚   â”‚
â”‚   â”œâ”€â”€ components/                         # All components
â”‚   â”‚   â”œâ”€â”€ [component-category]/           # Component category (e.g., ui, context)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ ui/                         # UI components folder
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentName.tsx       # Individual component file
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AnotherComponent.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts                # Export all UI components
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/                      # Component-specific hooks (optional)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useComponentHook.ts     # Hook used by components in this category
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useAnotherHook.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts                # Export all component hooks
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ context/                    # Component-specific context/provider (optional)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentProvider.tsx   # Provider wrapper component
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentContext.ts     # Context definition
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts                # Export provider and context
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ interface/                  # Component-specific TypeScript types
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentName.interface.ts # Types for specific component
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AnotherComponent.interface.ts # Types for another component
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useComponentHook.interface.ts # Types for component hooks (if exists)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentProvider.interface.ts # Types for provider/context (if exists)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts                # Export all types
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ __tests__/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentName.test.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AnotherComponent.test.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useComponentHook.test.tsx # Component hook tests (if exists)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentProvider.test.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ integration.test.tsx    # Component category integration tests
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ docs/                       # Component-specific documentation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md                # Category overview
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentName.md        # Component documentation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AnotherComponent.md     # Another component documentation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useComponentHook.md     # Component hook documentation (if exists)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ComponentProvider.md    # Provider documentation (if exists)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ index.ts                    # Category main export (ui + hooks + context + types)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ index.ts                        # Export all components
â”‚   â”‚
â”‚   â””â”€â”€ index.ts                            # Main package entry point (exports from hooks and components)
```

---

## ğŸ¯ Feature Structure Pattern

### Hooks Folder Purpose

The `src/hooks/` folder contains **common/core hooks** that can be used anywhere in the application. These are reusable, standalone hooks that are not tied to any specific component.

### Each Feature Must Contain:

#### **1. hooks/** (Required)
- Contains all hooks related to this feature
- Each hook in a separate file: `useHookName.ts`
- Must have `index.ts` to export all hooks
- This is the core of every feature
- **Purpose**: Common/core hooks usable anywhere

#### **2. context/** (Optional - Only if needed)
- Contains provider component and context
- `FeatureProvider.tsx` - Wrapper component for shared state
- `FeatureContext.ts` - Context definition
- Must have `index.ts` to export provider and context
- **Use when**: Multiple hooks need shared state OR global configuration needed

#### **3. interface/** (Required)
- Contains all TypeScript types for this feature
- Each hook has its own interface file: `useHookName.interface.ts`
- Each provider/context has its own interface file: `FeatureProvider.interface.ts`
- If hook and provider are tightly coupled, they can share one interface file
- Must have `index.ts` to export all types
- Types are scoped to this feature only

#### **4. __tests__/** (Required)
- Contains all tests for this feature
- `hooks/` subfolder - Tests for each hook
- `context/` subfolder - Tests for provider/context (if exists)
- `integration.test.tsx` - Feature-level integration tests

#### **5. docs/** (Required)
- Contains all documentation for this feature
- `README.md` - Feature overview and quick start
- `useHookName.md` - Individual hook documentation files (one per hook)
- `FeatureProvider.md` - Provider/context documentation (if exists)
- **Note**: All documentation files are in the same folder (no nested subfolders)

#### **6. index.ts** (Required)
- Main feature export file at root of feature folder
- Re-exports everything from hooks, context (if exists), and interface
- Entry point for the feature

---

## ğŸ¯ Component Structure Pattern

### Components Organization

Components are organized by category in `src/components/[component-category]/`. Each category can have:
- UI components
- Component-specific hooks (used only within that category or exported)
- Context providers (optional)
- Types, tests, and documentation

**Key Difference from Hooks Folder:**
- `src/hooks/` - Contains **common/core hooks** usable anywhere (no components)
- `src/components/[category]/hooks/` - Contains **component-specific hooks** used by components in that category (can be exported or internal)

#### **1. Component Categories**

Component categories are organized in `src/components/[component-category]/` where `[component-category]` can be:
- `ui` - For general UI components (buttons, modals, inputs, etc.)
- `context` - For context providers (theme, auth, config, etc.)
- Any other category name as needed (e.g., `forms`, `layout`, `navigation`, etc.)

Each [component-category] follows the same structure pattern with `ui/`, `hooks/`, `context/`, `interface/`, `__tests__/`, `docs/`, and `index.ts` folders.

#### **2. Component Category Structure**

Each [component-category] folder must contain:

#### **1. ui/** (Required)
- Contains all UI components related to this category
- Each component in a separate file: `ComponentName.tsx`
- Must have `index.ts` to export all UI components
- **Examples**: `Button.tsx`, `Modal.tsx`, `Input.tsx`
- **Location**: `src/components/[component-category]/ui/`

#### **2. hooks/** (Optional - Only if needed)
- Contains component-specific hooks used by components in this category
- Each hook in a separate file: `useComponentHook.ts`
- Must have `index.ts` to export all component hooks
- **Use when**: Hooks are specific to components in this category
- **Can be**: Internal (used only within category) or exported (usable outside category)
- **Location**: `src/components/[component-category]/hooks/`
- **Note**: These are different from common/core hooks in `src/hooks/` - these are component-specific

#### **3. context/** (Optional - Only if needed)
- Contains provider component and context for shared state
- `ComponentProvider.tsx` - Wrapper component for shared state
- `ComponentContext.ts` - Context definition
- Must have `index.ts` to export provider and context
- **Use when**: Multiple components need shared state OR global configuration needed
- **Location**: `src/components/[component-category]/context/`

#### **4. interface/** (Required)
- Contains all TypeScript types for this category
- Each component has its own interface file: `ComponentName.interface.ts`
- Each provider/context has its own interface file: `ComponentProvider.interface.ts`
- If component and provider are tightly coupled, they can share one interface file
- Must have `index.ts` to export all types
- Types are scoped to this category only
- **Location**: `src/components/[component-category]/interface/`

#### **5. __tests__/** (Required)
- Contains all tests for this category
- All test files in the same folder (no nested subfolders)
- Tests for each UI component: `ComponentName.test.tsx`
- Tests for component hooks: `useComponentHook.test.tsx` (if exists)
- Tests for provider/context: `ComponentProvider.test.tsx` (if exists)
- `integration.test.tsx` - Category-level integration tests
- **Location**: `src/components/[component-category]/__tests__/`

#### **6. docs/** (Required)
- Contains all documentation for this category
- `README.md` - Category overview and quick start
- `ComponentName.md` - Individual component documentation files (one per component)
- `ComponentProvider.md` - Provider/context documentation (if exists)
- **Note**: All documentation files are in the same folder (no nested subfolders)
- **Location**: `src/components/[component-category]/docs/`

#### **7. index.ts** (Required)
- Main category export file at root of category folder
- Re-exports everything from ui, hooks (if exists), context (if exists), and interface
- Entry point for the category
- **Location**: `src/components/[component-category]/index.ts`

#### **8. Component Requirements**

- **SSR-First**: All components MUST be compatible with Next.js and server-side rendering
- **Type-Safe**: Full TypeScript support with proper prop types
- **Accessible**: Follow WCAG guidelines and include proper ARIA attributes
- **Performance**: Optimize with React.memo, useMemo, useCallback when appropriate
- **Error Resilient**: Include error boundaries and graceful error handling
- **Zero Dependencies**: No external dependencies (except React and React-DOM)


---

## ğŸ“ Required Test Cases for Hooks

### Every Hook Must Have These 8 Tests:

#### **1. Initialization Test**
- Verify hook initializes with correct default values
- Test default state values
- Test initial return values
- Verify proper type inference

#### **2. SSR Compatibility Test**
- Ensure hook works with Next.js server-side rendering
- Test hook doesn't crash when `window` is undefined
- Verify returns fallback values on server
- Test handles missing browser APIs gracefully

#### **3. State Update Test**
- Verify hook updates state correctly
- Test setter functions work
- Test state updates trigger re-renders
- Test async updates work correctly

#### **4. Error Handling Test**
- Ensure hook handles errors gracefully
- Test try-catch blocks work
- Verify errors don't crash the hook
- Test `console.warn` is called (not `console.error`)
- Verify fallback values are used on error

#### **5. Cleanup Test**
- Verify no memory leaks on unmount
- Test event listeners are removed
- Test subscriptions are cleaned up
- Test timers are cleared
- Verify no memory leaks

#### **6. Options/Configuration Test**
- Test all configuration options work
- Verify each option property works as expected
- Test default options are applied
- Test custom options override defaults

#### **7. Edge Cases Test**
- Test boundary conditions and unusual inputs
- Test null/undefined values
- Test empty strings
- Test special characters
- Test large data sets
- Test race conditions

#### **8. TypeScript Type Test** (if applicable)
- Ensure generic types work correctly
- Test type inference works
- Test generic constraints work
- Verify type errors are caught

---

## ğŸ“ File Naming Conventions

### Feature Folder
- **Format**: `kebab-case` or `camelCase`
- **Examples**: `storage`, `browser`, `timer`, `ui`
- **Location**: `src/hooks/[feature-name]/`

### Hook Files
- **Format**: `useCamelCase.ts`
- **Examples**: `useLocalStorage.ts`, `useMediaQuery.ts`, `useClickOutside.ts`
- **Location**: `src/hooks/[feature-name]/hooks/`

### Context/Provider Files (Hooks)
- **Format**: `{Feature}Provider.tsx` and `{Feature}Context.ts`
- **Examples**: `StorageProvider.tsx`, `BrowserContext.ts`
- **Location**: `src/hooks/[feature-name]/context/`

### Interface/Type Files (Hooks)
- **Format**: `{hookName}.interface.ts` or `{ProviderName}.interface.ts`
- **Examples**: `useLocalStorage.interface.ts`, `useOnline.interface.ts`, `StorageProvider.interface.ts`
- **Rule**: Each hook gets its own interface file, each provider gets its own interface file
- **Location**: `src/hooks/[feature-name]/interface/`

### Test Files (Hooks)
- **Format**: `useCamelCase.test.tsx` (matches hook name exactly)
- **Examples**: `useLocalStorage.test.tsx`, `StorageProvider.test.tsx`
- **Location**: `src/hooks/[feature-name]/__tests__/hooks/` (for hooks) or `src/hooks/[feature-name]/__tests__/context/` (for providers)

### Documentation Files (Hooks)
- **Format**: Markdown files with descriptive names
- **Examples**: `README.md`, `useHookName.md`, `FeatureProvider.md`
- **Location**: `src/hooks/[feature-name]/docs/` (flat structure, no nested folders)
- **Naming**: Hook docs use hook name: `useHookName.md`, Provider docs use provider name: `FeatureProvider.md`

### Component Category Folders
- **Format**: `kebab-case` or `camelCase`
- **Examples**: `ui`, `context`, `forms`, `layout`
- **Location**: `src/components/[component-category]/`
- **Purpose**: Organize components by category (UI components, context providers, etc.)

### Component Files (UI Components)
- **Format**: `PascalCase.tsx`
- **Examples**: `Button.tsx`, `Modal.tsx`, `Input.tsx`, `ComboSelect.tsx`
- **Location**: `src/components/[component-category]/ui/`
- **Rule**: Each component in its own file, named exactly as the component
- **Must have**: `index.ts` in the `ui/` folder to export all components

### Component-Specific Hook Files
- **Format**: `useCamelCase.ts`
- **Examples**: `useComboSelect.ts`, `useModal.ts`, `useFormField.ts`
- **Location**: `src/components/[component-category]/hooks/`
- **Rule**: Each hook in its own file, named with `use` prefix
- **Purpose**: Hooks specific to components in this category (can be internal or exported)
- **Must have**: `index.ts` in the `hooks/` folder to export all component hooks
- **Note**: These are different from common/core hooks in `src/hooks/`

### Component Context/Provider Files
- **Format**: `{Component}Provider.tsx` and `{Component}Context.ts`
- **Examples**: `ButtonProvider.tsx`, `ModalContext.ts`
- **Location**: `src/components/[component-category]/context/`
- **Rule**: Only create if components in the category need shared state

### Component Interface Files
- **Format**: `ComponentName.interface.ts`, `useComponentHook.interface.ts`, or `ComponentProvider.interface.ts`
- **Examples**: `Button.interface.ts`, `Modal.interface.ts`, `useComboSelect.interface.ts`, `ButtonProvider.interface.ts`
- **Location**: `src/components/[component-category]/interface/`
- **Rule**: Each component gets its own interface file, each hook gets its own interface file, each provider gets its own interface file

### Component Test Files
- **Format**: `ComponentName.test.tsx` or `useComponentHook.test.tsx` (matches name exactly)
- **Examples**: `Button.test.tsx`, `Modal.test.tsx`, `useComboSelect.test.tsx`, `ButtonProvider.test.tsx`
- **Location**: `src/components/[component-category]/__tests__/` (flat structure, no nested folders)
- **Rule**: All test files are in the same `__tests__/` folder, no subfolders

### Component Documentation Files
- **Format**: Markdown files with component or hook name
- **Examples**: `Button.md`, `Modal.md`, `useComboSelect.md`, `ButtonProvider.md`
- **Location**: `src/components/[component-category]/docs/` (flat structure, no nested folders)
- **Naming**: Component docs use component name: `ComponentName.md`, Hook docs use hook name: `useComponentHook.md`, Provider docs use provider name: `ComponentProvider.md`

### Index Files (Barrel Exports)
- **Format**: `index.ts`
- **Required in**: Every subfolder (hooks, context, interface for features; ui, hooks, context, interface for component categories)
- **Purpose**: Centralized exports for clean imports

---

## ğŸ§ª Testing Rules & Required Test Cases

### Test File Organization

#### Hook Feature Tests
```
src/hooks/[feature-name]/__tests__/
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useHookName.test.tsx       # Hook tests
â”‚   â””â”€â”€ useAnotherHook.test.tsx
â”œâ”€â”€ context/
â”‚   â””â”€â”€ FeatureProvider.test.tsx   # Provider tests
â””â”€â”€ integration.test.tsx           # Integration tests
```

#### Component Category Tests
```
src/components/[component-category]/__tests__/
â”œâ”€â”€ ComponentName.test.tsx          # UI component tests
â”œâ”€â”€ AnotherComponent.test.tsx
â”œâ”€â”€ useComponentHook.test.tsx      # Component hook tests (if exists)
â”œâ”€â”€ ComponentProvider.test.tsx     # Provider tests (if exists)
â””â”€â”€ integration.test.tsx           # Category integration tests
```

---

## ğŸ“ Required Test Cases for Context/Providers

### Every Provider Must Have These 6 Tests:

#### **1. Provider Rendering Test**
- Verify provider renders children correctly
- Test provider wraps children
- Test children can access context
- Verify provider doesn't cause extra re-renders

#### **2. Context Value Test**
- Verify context provides correct values
- Test context value is accessible
- Test context value has correct shape
- Test context value updates correctly

#### **3. Hook Integration Test**
- Test companion hook works with provider
- Test hook can access context
- Test hook throws error when used outside provider (if applicable)
- Test hook receives updates from context

#### **4. Provider Props Test**
- Test provider configuration props
- Test config prop works
- Test default config is applied
- Test invalid config is handled

#### **5. State Update Test**
- Verify state changes propagate to consumers
- Test state updates trigger re-renders
- Test all consumers receive updates
- Test updates are batched correctly

#### **6. Multiple Consumers Test**
- Test multiple components can consume context
- Test multiple children access same context
- Test all consumers stay in sync
- Test updates reach all consumers

---

## ğŸ“ Required Test Cases for Component-Specific Hooks

### Component-Specific Hooks vs Common/Core Hooks

**Common/Core Hooks** (`src/hooks/`):
- Reusable hooks usable anywhere in the application
- Not tied to any specific component
- Follow the 8 test suites defined for hooks

**Component-Specific Hooks** (`src/components/[category]/hooks/`):
- Hooks used by components within a specific category
- Can be internal (used only within category) or exported (usable outside)
- Follow the same 8 test suites as common/core hooks

### Every Component-Specific Hook Must Have These 8 Tests:

#### **1. Initialization Test**
- Verify hook initializes with correct default values
- Test default state values
- Test initial return values
- Verify proper type inference

#### **2. SSR Compatibility Test**
- Ensure hook works with Next.js server-side rendering
- Test hook doesn't crash when `window` is undefined
- Verify returns fallback values on server
- Test handles missing browser APIs gracefully

#### **3. State Update Test**
- Verify hook updates state correctly
- Test setter functions work
- Test state updates trigger re-renders
- Test async updates work correctly

#### **4. Error Handling Test**
- Ensure hook handles errors gracefully
- Test try-catch blocks work
- Verify errors don't crash the hook
- Test `console.warn` is called (not `console.error`)
- Verify fallback values are used on error

#### **5. Cleanup Test**
- Verify no memory leaks on unmount
- Test event listeners are removed
- Test subscriptions are cleaned up
- Test timers are cleared
- Verify no memory leaks

#### **6. Options/Configuration Test**
- Test all configuration options work
- Verify each option property works as expected
- Test default options are applied
- Test custom options override defaults

#### **7. Edge Cases Test**
- Test boundary conditions and unusual inputs
- Test null/undefined values
- Test empty strings
- Test special characters
- Test large data sets
- Test race conditions

#### **8. TypeScript Type Test** (if applicable)
- Ensure generic types work correctly
- Test type inference works
- Test generic constraints work
- Verify type errors are caught

---

## ğŸ“ Required Test Cases for Components

### Every Component Must Have These 8 Tests:

#### **1. Rendering Test**
- Verify component renders without errors
- Test component renders with required props
- Test component renders with optional props
- Verify proper type inference for props

#### **2. SSR Compatibility Test**
- Ensure component works with Next.js server-side rendering
- Test component doesn't crash when `window` is undefined
- Verify component renders correctly on server
- Test handles missing browser APIs gracefully (if applicable)

#### **3. Props Test**
- Test all props work correctly
- Test required props are enforced
- Test optional props have correct defaults
- Test prop validation and error handling
- Test prop changes trigger re-renders

#### **4. User Interaction Test**
- Test click handlers work
- Test keyboard navigation works
- Test form inputs work correctly
- Test user events trigger correct callbacks
- Test disabled states prevent interactions

#### **5. Accessibility Test**
- Test ARIA attributes are present and correct
- Test keyboard navigation works
- Test screen reader compatibility
- Test focus management
- Test color contrast (if applicable)

#### **6. Error Handling Test**
- Ensure component handles errors gracefully
- Test try-catch blocks work (if applicable)
- Verify errors don't crash the component
- Test error boundaries work correctly
- Verify fallback UI is displayed on error

#### **7. Edge Cases Test**
- Test boundary conditions and unusual inputs
- Test null/undefined values
- Test empty strings
- Test special characters
- Test large data sets
- Test rapid prop changes

#### **8. TypeScript Type Test**
- Ensure prop types work correctly
- Test type inference works
- Test generic types work (if applicable)
- Verify type errors are caught
- Test required vs optional props

---

## ğŸ“ Required Integration Tests

### Feature Integration Test (integration.test.tsx)

#### **Purpose**: Test hooks and context working together

#### **Required Integration Tests (3 minimum):**

1. **Multiple Hooks Together Test**
   - Test multiple hooks from the same feature work together
   - Verify hooks don't interfere with each other
   - Test shared state management (if applicable)

2. **Hooks with Provider Test**
   - Test hooks work correctly with feature provider
   - Verify hook + context integration
   - Test data flow between hooks and provider

3. **Real-world Scenario Test**
   - Test a complete user flow using the feature
   - Example: User stores data, updates it, and removes it
   - Test all feature components working together in a realistic scenario

### Component Category Integration Test (integration.test.tsx)

#### **Purpose**: Test components and component-specific hooks working together within a category

#### **Required Integration Tests (3 minimum):**

1. **Multiple Components Together Test**
   - Test multiple components from the same category work together
   - Verify components don't interfere with each other
   - Test shared state management (if applicable)

2. **Components with Hooks and Provider Test**
   - Test components work correctly with component-specific hooks
   - Test components work correctly with category provider
   - Verify component + hook + context integration
   - Test data flow between components, hooks, and provider

3. **Real-world Scenario Test**
   - Test a complete user flow using the category components
   - Example: User fills a form with multiple components using component-specific hooks
   - Test all category components, hooks, and providers working together in a realistic scenario

---

## ğŸ“š Documentation Rules & Required Content

### Documentation File Organization

#### Hook Feature Documentation
```
src/hooks/[feature-name]/docs/
â”œâ”€â”€ README.md                   # Feature overview
â”œâ”€â”€ useHookName.md              # Individual hook documentation
â”œâ”€â”€ useAnotherHook.md          # Another hook documentation
â””â”€â”€ FeatureProvider.md          # Provider/context documentation (if exists)
```

#### Component Category Documentation
```
src/components/[component-category]/docs/
â”œâ”€â”€ README.md                   # Category overview
â”œâ”€â”€ ComponentName.md            # Individual component documentation
â”œâ”€â”€ AnotherComponent.md         # Another component documentation
â”œâ”€â”€ useComponentHook.md         # Component hook documentation (if exists)
â””â”€â”€ ComponentProvider.md       # Provider/context documentation (if exists)
```

**Note**: All documentation files are stored directly in the `docs/` folder with no nested subfolders.

---

## ğŸ“ Required Documentation Content for Hooks

### Every Hook Documentation File Must Include:

#### **1. Title**
- Clear, descriptive title using the hook name
- Format: `# useHookName`
- Should match the hook file name exactly

#### **2. Description & Use Cases**
- **Description**: Brief explanation of what the hook does
- **Problem it solves**: Explain the specific problem or need this hook addresses
- **Use cases**: List common scenarios where this hook is valuable
- **Benefits**: Highlight key advantages and why developers should use it
- **When to use**: Guidance on when this hook is the right choice

#### **3. Quick Example**
- Simple, minimal code example showing basic usage
- Should demonstrate the most common use case
- Include import statement
- Show the hook in a functional component
- Keep it concise and easy to understand

#### **4. Signature/API**
- TypeScript function signature
- Show the complete type definition
- Include all generic types if applicable

#### **5. Parameters (Options)**
- **Detailed explanation of each parameter**:
  - Parameter name and type
  - Whether it's required or optional
  - Default value (if any)
  - Description of what it does
  - When to use it
  - Possible values/range
  - Example values
  - Any constraints or limitations

#### **6. Return Value / Output Object**
- **Detailed explanation of each returned property**:
  - Property name and type
  - Description of what it represents
  - Possible values/range
  - When it changes or updates
  - Default values
  - When to use it
  - Example values
  - Any special cases (null, undefined, Infinity, etc.)

#### **7. SSR / Next.js Compatibility**
- Explain SSR behavior
- What values are returned during server-side rendering
- How it handles hydration
- Any special considerations for Next.js

#### **8. Common Patterns**
- Real-world usage patterns
- Best practices
- Common use cases with code examples
- Integration with other hooks or libraries

#### **9. Browser Compatibility**
- Browser support information
- API availability
- Fallback behavior
- Polyfill requirements (if any)

#### **10. Performance Notes**
- Performance considerations
- When the hook updates
- Memory usage
- Optimization tips

#### **11. Troubleshooting**
- Common issues and solutions
- Error scenarios
- Debugging tips
- Known limitations

---

## ğŸ“ Required Documentation Content for Providers/Context

### Every Provider Documentation File Must Include:

#### **1. Title**
- Clear, descriptive title using the provider name
- Format: `# FeatureProvider`
- Should match the provider file name exactly

#### **2. Description & Use Cases**
- **Description**: Brief explanation of what the provider does
- **Problem it solves**: Explain why a provider is needed
- **Use cases**: When to use a provider vs standalone hooks
- **Benefits**: Shared state, global configuration, performance benefits
- **When to use**: Guidance on when a provider is necessary

#### **3. Quick Example**
- Simple example showing provider setup
- Show how to wrap components
- Show how to use companion hooks
- Include import statements

#### **4. Signature/API**
- TypeScript component signature
- Props interface
- Context value type

#### **5. Provider Props**
- **Detailed explanation of each prop**:
  - Prop name and type
  - Whether it's required or optional
  - Default value (if any)
  - Description of what it does
  - When to use it
  - Possible values
  - Example values

#### **6. Context Value**
- **Detailed explanation of each context property**:
  - Property name and type
  - Description of what it provides
  - How to access it
  - When it updates
  - Example usage

#### **7. Companion Hooks**
- List hooks that work with this provider
- How to use them together
- Examples of integration

#### **8. SSR / Next.js Compatibility**
- Provider behavior during SSR
- How to use in Next.js App Router
- How to use in Next.js Pages Router
- Hydration considerations

#### **9. Common Patterns**
- Provider setup patterns
- Best practices
- Common use cases with code examples
- Multiple provider usage

#### **10. Performance Notes**
- Provider performance impact
- Re-render behavior
- Optimization strategies

#### **11. Troubleshooting**
- Common issues and solutions
- Provider setup problems
- Context access issues
- Debugging tips

---

## ğŸ“ Required Documentation Content for Component-Specific Hooks

### Component-Specific Hook Documentation

Component-specific hooks follow the same documentation structure as common/core hooks but are documented within the component category's `docs/` folder.

### Every Component-Specific Hook Documentation File Must Include:

#### **1. Title**
- Clear, descriptive title using the hook name
- Format: `# useComponentHook`
- Should match the hook file name exactly

#### **2. Description & Use Cases**
- **Description**: Brief explanation of what the hook does
- **Problem it solves**: Explain the specific problem this hook addresses for components in this category
- **Use cases**: List common scenarios where this hook is used with components
- **Benefits**: Highlight key advantages
- **When to use**: Guidance on when to use this hook vs common/core hooks

#### **3. Quick Example**
- Simple, minimal code example showing basic usage
- Should demonstrate usage with components in the category
- Include import statement
- Show the hook in a functional component
- Keep it concise and easy to understand

#### **4. Signature/API**
- TypeScript function signature
- Show the complete type definition
- Include all generic types if applicable

#### **5. Parameters (Options)**
- **Detailed explanation of each parameter**:
  - Parameter name and type
  - Whether it's required or optional
  - Default value (if any)
  - Description of what it does
  - When to use it
  - Possible values/range
  - Example values
  - Any constraints or limitations

#### **6. Return Value / Output Object**
- **Detailed explanation of each returned property**:
  - Property name and type
  - Description of what it represents
  - Possible values/range
  - When it changes or updates
  - Default values
  - When to use it
  - Example values
  - Any special cases (null, undefined, Infinity, etc.)

#### **7. SSR / Next.js Compatibility**
- Explain SSR behavior
- What values are returned during server-side rendering
- How it handles hydration
- Any special considerations for Next.js

#### **8. Common Patterns**
- Real-world usage patterns with components
- Best practices
- Common use cases with code examples
- Integration with components in the category

#### **9. Browser Compatibility**
- Browser support information
- API availability
- Fallback behavior
- Polyfill requirements (if any)

#### **10. Performance Notes**
- Performance considerations
- When the hook updates
- Memory usage
- Optimization tips

#### **11. Troubleshooting**
- Common issues and solutions
- Error scenarios
- Debugging tips
- Known limitations

---

## ğŸ“ Required Documentation Content for Components

### Every Component Documentation File Must Include:

#### **1. Title**
- Clear, descriptive title using the component name
- Format: `# ComponentName`
- Should match the component file name exactly

#### **2. Description & Use Cases**
- **Description**: Brief explanation of what the component does
- **Problem it solves**: Explain the UI/UX problem it addresses
- **Use cases**: Common scenarios where this component is used
- **Benefits**: Key advantages
- **When to use**: Guidance on component selection

#### **3. Quick Example**
- Simple example showing component usage
- Include import statement
- Show basic props
- Minimal working example

#### **4. Signature/API**
- TypeScript component signature
- Props interface
- All prop types

#### **5. Component Props**
- **Detailed explanation of each prop**:
  - Prop name and type
  - Whether it's required or optional
  - Default value (if any)
  - Description of what it does
  - When to use it
  - Possible values
  - Example values
  - Visual examples (if applicable)

#### **6. Component Behavior**
- How the component renders
- State management
- Event handling
- Lifecycle behavior

#### **7. Styling & Customization**
- Styling options
- CSS classes
- Theme support
- Customization methods

#### **8. Accessibility**
- ARIA attributes
- Keyboard navigation
- Screen reader support
- Accessibility best practices

#### **9. Common Patterns**
- Usage patterns
- Best practices
- Common use cases with examples
- Integration examples

#### **10. Performance Notes**
- Component performance
- Rendering optimization
- When to use memoization

#### **11. Troubleshooting**
- Common issues and solutions
- Styling problems
- Behavior issues
- Debugging tips

---

## ğŸ“Š Test File Structure Template

### Hook Test File Structure:
```
describe('[HookName]', () => {
  beforeEach(() => { /* Setup */ })
  afterEach(() => { /* Cleanup */ })
  
  describe('Initialization', () => { /* Tests */ })
  describe('SSR Compatibility', () => { /* Tests */ })
  describe('State Updates', () => { /* Tests */ })
  describe('Error Handling', () => { /* Tests */ })
  describe('Cleanup', () => { /* Tests */ })
  describe('Options', () => { /* Tests */ })
  describe('Edge Cases', () => { /* Tests */ })
  describe('TypeScript Types', () => { /* Tests */ })
})
```

### Provider Test File Structure:
```
describe('[FeatureProvider]', () => {
  beforeEach(() => { /* Setup */ })
  afterEach(() => { /* Cleanup */ })
  
  describe('Rendering', () => { /* Tests */ })
  describe('Context Value', () => { /* Tests */ })
  describe('Hook Integration', () => { /* Tests */ })
  describe('Props', () => { /* Tests */ })
  describe('State Updates', () => { /* Tests */ })
  describe('Multiple Consumers', () => { /* Tests */ })
})
```

### Component Test File Structure:
```
describe('[ComponentName]', () => {
  beforeEach(() => { /* Setup */ })
  afterEach(() => { /* Cleanup */ })
  
  describe('Rendering', () => { /* Tests */ })
  describe('SSR Compatibility', () => { /* Tests */ })
  describe('Props', () => { /* Tests */ })
  describe('User Interaction', () => { /* Tests */ })
  describe('Accessibility', () => { /* Tests */ })
  describe('Error Handling', () => { /* Tests */ })
  describe('Edge Cases', () => { /* Tests */ })
  describe('TypeScript Types', () => { /* Tests */ })
})
```

### Component-Specific Hook Test File Structure:
```
describe('[useComponentHook]', () => {
  beforeEach(() => { /* Setup */ })
  afterEach(() => { /* Cleanup */ })
  
  describe('Initialization', () => { /* Tests */ })
  describe('SSR Compatibility', () => { /* Tests */ })
  describe('State Updates', () => { /* Tests */ })
  describe('Error Handling', () => { /* Tests */ })
  describe('Cleanup', () => { /* Tests */ })
  describe('Options', () => { /* Tests */ })
  describe('Edge Cases', () => { /* Tests */ })
  describe('TypeScript Types', () => { /* Tests */ })
})
```

### Integration Test File Structure:
```
describe('[Feature] Integration', () => {
  beforeEach(() => { /* Setup */ })
  afterEach(() => { /* Cleanup */ })
  
  describe('Multiple Hooks', () => { /* Tests */ })
  describe('Hooks with Provider', () => { /* Tests */ })
  describe('Real-world Scenarios', () => { /* Tests */ })
})
```

### Component Category Integration Test File Structure:
```
describe('[ComponentCategory] Integration', () => {
  beforeEach(() => { /* Setup */ })
  afterEach(() => { /* Cleanup */ })
  
  describe('Multiple Components', () => { /* Tests */ })
  describe('Components with Hooks and Provider', () => { /* Tests */ })
  describe('Real-world Scenarios', () => { /* Tests */ })
})
```
